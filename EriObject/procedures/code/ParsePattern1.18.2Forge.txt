obj = new Object(){
    private List<Object> parsePattern(String patternStr, String input) {
        // Définition des sous-motifs regex pour chaque placeholder
        String numericPattern = "(-?\\d+(?:\\.\\d+)?)";                     // nombre entier ou décimal (Double)
        String stringPattern  = "(?:'([^']*)'|\\\"([^\\\"]*)\\\")";        // texte entre quotes simples ou doubles
        String booleanPattern = "(true|false)";                           // booléen "true" ou "false"

        // Construire le motif regex complet en insérant les motifs correspondants aux placeholders
        StringBuilder regexBuilder = new StringBuilder();
        Pattern placeholderRegex = Pattern.compile("%(NUMERIC|STRING|BOOLEAN)%");
        Matcher phMatcher = placeholderRegex.matcher(patternStr);
        int lastEnd = 0;
        List<String> placeholderTypes = new ArrayList<>();  // garde la liste des types de placeholders dans l'ordre
        while (phMatcher.find()) {
            // Ajouter la partie littérale (fixe) précédant le placeholder actuel, en l'échappant pour le regex
            String literalText = patternStr.substring(lastEnd, phMatcher.start());
            if (!literalText.isEmpty()) {
                regexBuilder.append(Pattern.quote(literalText));
            }
            // Insérer le motif du placeholder selon son type
            String type = phMatcher.group(1);  // "NUMERIC", "STRING" ou "BOOLEAN"
            switch (type) {
                case "NUMERIC":
                    regexBuilder.append(numericPattern);
                    placeholderTypes.add("NUMERIC");
                    break;
                case "STRING":
                    regexBuilder.append(stringPattern);
                    placeholderTypes.add("STRING");
                    break;
                case "BOOLEAN":
                    regexBuilder.append(booleanPattern);
                    placeholderTypes.add("BOOLEAN");
                    break;
            }
            lastEnd = phMatcher.end();
        }
        // Ajouter le reste de texte littéral après le dernier placeholder, le cas échéant
        if (lastEnd < patternStr.length()) {
            String literalText = patternStr.substring(lastEnd);
            regexBuilder.append(Pattern.quote(literalText));
        }
        // Compiler le motif regex final
        Pattern finalPattern = Pattern.compile(regexBuilder.toString());
        Matcher matcher = finalPattern.matcher(input);

        // Vérifier que l'intégralité de la chaîne d'entrée correspond au motif
        if (!matcher.matches()) {
            return new ArrayList<>(); // aucune correspondance complète trouvée, retourner liste vide
        }

        // Extraire les groupes capturés et les convertir dans les bons types
        List<Object> result = new ArrayList<>();
        int groupIndex = 1;
        for (String type : placeholderTypes) {
            switch (type) {
                case "NUMERIC":
                    String numStr = matcher.group(groupIndex);
                    // Convertir en Double
                    result.add(Double.valueOf(numStr));
                    groupIndex += 1;
                    break;
                case "BOOLEAN":
                    String boolStr = matcher.group(groupIndex);
                    // Convertir en Boolean (true/false)
                    result.add(Boolean.valueOf(boolStr));
                    groupIndex += 1;
                    break;
                case "STRING":
                    // Deux groupes de capture possibles pour le contenu du string (selon quote simple ou double)
                    String content = matcher.group(groupIndex);
                    if (content == null) {
                        content = matcher.group(groupIndex + 1);
                    }
                    result.add(content);
                    groupIndex += 2;  // sauter les deux groupes utilisés par %STRING%
                    break;
            }
        }
        return result;
    }
}.parsePattern(${input$pattern}, ${input$String});